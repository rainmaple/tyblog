{"pages":[{"title":"about","text":"","link":"/tyblog/about/index.html"}],"posts":[{"title":"Cpp11中智能指针的使用","text":"Unique_ptrunique_ptr 它承担管理资源的完整和排他的责任, 是一个智能指针，它通过指针拥有和管理另一个对象，并在 unique_ptr 超出范围时处理该对象。会在超出范围后尝试删除该对象。unique_ptr 的关键属性之一：如果有一个由 unique_ptr 管理的资源，则不应尝试在 unique_ptr 之外自己管理该资源。unique_ptr 的契约是 “unique_ptr 独家拥有资源” ，所以如果你拿走那个资源并自己释放它，你就违反了契约。 当且仅当 unique_ptr 管理对象被销毁 unique_ptr 管理对象通过 operator= 或 reset() 分配了另一个指针。 则指针会使用关联的删除器处理对象 创建1234567int main(){ // 创建一个unique_ptr实例 unique_ptr&lt;int&gt; ptrInt(new int(10)); auto ptr = std::make_unique&lt;int&gt;(); cout &lt;&lt; *ptrInt;} 移动和赋值unique_ptr虽然没有支持普通的拷贝和赋值操作，但却提供了一种移动机制来将指针的所有权从一个unique_ptr转移给另一个unique_ptr。如果需要转移所有权，可以使用std::move()函数。 1234567int main() { unique_ptr&lt;int&gt; ptrInt(new int(5)); unique_ptr&lt;int&gt; ptrInt_copy = std::move(ptrInt); // 转移所有权 //cout &lt;&lt; *ptrInt &lt;&lt; endl; // 出错，pInt为空 cout &lt;&lt; *ptrInt_copy &lt;&lt; endl;} 对象的托管只有非常量 unique_ptr 才能将托管对象的所有权转移到另一个 unique_ptr。 如果对象的生命周期由 const std::unique_ptr 管理，则它仅限于创建指针的范围。 若 T 是某个基 B 的派生类，则 std::unique_ptr 可隐式转换为 *std::unique_ptr*。 结果 std::unique_ptr 的默认删除器将对 B 使用运算符 delete，除非 B 的析构函数是虚拟的，否则会导致未定义的行为。 unique_ptr不共享它的指针，是一个仅能移动（move_only）的类型。它无法复制到其他 unique_ptr*，无法通过值传递到函数，也无法用于需要副本的任何标准模板库 (STL) 算法。只能移动unique_ptr*。这意味着，内存资源所有权将转移到另一 unique_ptr，并且原始 ** unique_ptr 不再拥有此资源。建议将对象限制为由一个所有者所有，因为多个所有权会使程序逻辑变得复杂。因此，当需要智能指针用于纯 C++ 对象时，可使用 unique_ptr，而当构造 unique_ptr 时，可使用make_unique 函数，同时也支持从函数中返回。 这里说明一件事，std::make_shared是c++11的一部分，但很可惜std::make_unique不是。它是在c++14里加入标准库的。假如你在使用c++11，也别担心，很容易写出一个基本的版本： 12345template&lt;typename T, typename... Args&gt;std::unique_ptr&lt;T&gt; make_unique(Args&amp;&amp;... params){ return std::unique_ptr&lt;T&gt;(new T(std::forward&lt;Args&gt;(params)...));} 使用unique_ptr来管理动态内存，只要unique_ptr指针创建成功，其析构函数都会被调用。确保动态资源被释放。这样就为动态申请的资源提供异常安全保证 123456void func(){ unique_ptr&lt;int&gt; ptr(new int(10)); // ...（抛出异常）} 仍然可以处理指针对象的内存回收 返回函数中申请的资源的所有权 123456789101112unique_ptr&lt;int&gt; func(int num){ unique_ptr&lt;int&gt; ptrInt(new int(num)); return ptrInt; // 返回unique_ptr}int main() { int num = 10; unique_ptr&lt;int&gt; ptr = func(num); cout &lt;&lt; *ptr &lt;&lt; endl; // 函数结束后，自动释放资源} 容器中保留指针 123456int main() { vector&lt;unique_ptr&lt;int&gt;&gt; vec; unique_ptr&lt;int&gt; ptr(new int(10)); vec.push_back(std::move(ptr)); } 标准库提供了一个可以管理动态数组的unique_ptr版本。 12345int main() { unique_ptr&lt;int[]&gt; p(new int[5] {1, 2, 3, 4, 5}); p[0] = 0; // 重载了operator[]} Shared_ptr它假设资源的所有所有权在不同的 shared_ptr 之间共享到一个资源。shared_ptr 是C++11提供的一种智能指针类，它足够智能，可以在任何地方都不使用时自动删除相关指针，从而帮助彻底消除内存泄漏和悬空指针的问题。它遵循共享所有权的概念，即不同的 shared_ptr 对象可以与相同的指针相关联，并在内部使用引用计数机制来实现这一点。每个 shared_ptr 对象在内部指向两个内存位置： 指向对象的指针。 用于控制引用计数数据的指针。 共享所有权如何在参考计数的帮助下工作： 当新的 shared_ptr 对象与指针关联时，则在其构造函数中，将与此指针关联的引用计数增加1。 当任何 shared_ptr 对象超出作用域时，则在其析构函数中，它将关联指针的引用计数减1。如果引用计数变为0，则表示没有其他 shared_ptr 对象与此内存关联，在这种情况下，它使用delete函数删除该内存。\\ 在构造的过程也需要注意方式 在初始化一个unique_ptr或者shared_ptr时，我们最好优先使用std::make_unique和std::make_shared。原因有一下几点： 异常安全性 123456789101112131415161718192021222324252627282930313233343536假设有如下函数声明：f1();void processcall(std::shared_ptr&lt;SimpleClass&gt; ptr,int p);调用processSimple的代码如下所示：handleSimple(std::shared_ptr&lt;SimpleClass&gt;(new S()),computeP()); 由于在C++中函数参数的执行顺序是不固定的，所以在上面对函数processInvestment调用中，函数参数的执行顺序很可能是这样的：new InvestmentcomputePriority()std::shared_ptr constructor这种执行顺序的风险是，如果在第二步，执行computePriority的过程中出现异常，那么在第一步中new出来的对象将变得不可访问，从而造成内存泄漏。通过make_ptr的方式，将new操作和shared_ptr的构造放在一起执行，就不会出现内存泄漏问题了。执行效率（对于shared_ptr而言）std::shared_ptr&lt;Investment&gt;ptr(new Investment); //方式1，new的方式在方式1中，会涉及到两次动态内存分配：第一次是new Investment时，为Investment对象分配空间。第二次是为控制块（Control Block）分配空间。auto pIn = std::make_shared&lt;Investment&gt;();//方式2，make_shared的方式在方式二中，一次动态内存分配就足够了，这是由于make_shared会为Investment对象和控制块（Control block）一次性分配一大块内存。由于只有一次内存分配，因而方式二提高了程序的执行效率。","link":"/tyblog/2022/05/15/Cpp11%E4%B8%AD%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/tyblog/2022/05/15/hello-world/"}],"tags":[],"categories":[]}